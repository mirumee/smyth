{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A versatile tool that enhances your AWS Lambda development experience.</p>"},{"location":"#installation","title":"Installation","text":"<p>It's recommended to install Smyth into your project as a development dependency to use the same Python interpreter as your project:</p> Poetrypip <pre><code>poetry add --group dev smyth\n</code></pre> <pre><code>pip install smyth\n</code></pre> <p>Define the following settings in your Lambda project's <code>pyproject.toml</code> file:</p> <pre><code>[tool.smyth]\nhost = \"0.0.0.0\"\nport = 8080\n\n[tool.smyth.handlers.saleor_handler]\nhandler_path = \"my_project.handlers.saleor.handler.saleor_http_handler\"\nurl_path = \"/saleor/{path:path}\"\n</code></pre> <p>See configuration for more settings and features.</p> <p>Run Smyth with:</p> <pre><code>python -m smyth\n</code></pre> <p>Also see</p> <p>Make sure to check out the links below for more serverless-oriented tools.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pure Python: The tool is entirely written in Python, offering flexibility to tailor it to your specific requirements.</li> <li>Customizability: Modify both the <code>event</code> and <code>context</code> data structures to suit your needs.</li> <li>State Persistence: Simulates both cold and warm starts. Lambda processes retain their state across invocations, mimicking the behavior of actual AWS Lambdas. The state is reset only when code changes trigger Uvicorn to reload.</li> <li>Efficiency: Streamlined and efficient, relying solely on Python to execute the code.</li> <li>Inspired by Serverless Framework: Takes cues from the Serverless framework, known for its effectiveness in managing serverless applications.</li> <li>Developer-Friendly: Tailored for Python web developers, it integrates seamlessly with common development tools and practices such as PDB, iPDB, VSCode debugging, and .env file support, ensuring a familiar and productive environment.</li> </ul>"},{"location":"#rationale","title":"Rationale","text":"<p>Despite extensive testing, nothing matched the efficiency we experienced when developing ASGI (e.g., FastAPI) applications. Here is an overview of the alternatives we evaluated:</p> <ul> <li> <p>Serverless (with the serverless-offline plugin): This seemed promising, deploying a Node.js server to invoke the lambda in a subprocess, effectively simulating the AWS Lambda runtime through an AWS API Gateway V2 proxy. However, its maintenance is lacking; for instance, a pending pull request to add Python 3.12 as a supported runtime has been unresolved for nearly three months. Additionally, the development experience is hindered by the absence of Python Debugger support.</p> </li> <li> <p>Localstack: While Localstack offers useful features, its lambda functionality is less satisfactory. Testing code requires building and \"uploading\" the lambda to Localstack for invocation, a process that takes about a minute\u2014far too slow for efficient local development.</p> </li> <li> <p>AWS SAM: Although newer and of higher quality than Serverless, AWS SAM offers fewer plugins and only supports pip for dependency management. While faster than Localstack, it still necessitates building the lambda for invocation.</p> </li> <li> <p>Running the code locally: We also explored using pytest to directly invoke lambda handlers. This approach is viable, but our specific needs require exposing lambdas over HTTP to interact with a remote (or local) instance of Saleor.</p> </li> <li> <p>CDK: A tool or framework that allows defining the Lambda stack in Python. It can spin up local Lambda invocations quickly and with many different events. However, it lacks the feature of HTTP exposure of the Lambda, which is critical when working with Saleor Apps.</p> </li> <li> <p>Flask: Flask could be used to invoke a handler from an endpoint. After a while of trying to make it work from a single entry point (i.e., one Docker container), we ended up with... well, this, but using a modern ASGI framework with Uvicorn as the HTTP server.</p> </li> </ul>"},{"location":"#how-smyth-works","title":"How Smyth Works","text":"<p>Understanding the components involved in the Smyth environment is crucial for effective development. Here's a breakdown of the key terms:</p> <ul> <li> <p>Uvicorn: An ASGI server responsible for translating incoming HTTP requests into Python callable formats that ASGI applications can understand. It serves as the interface between the web and your application, enabling asynchronous web server capabilities for Python.</p> </li> <li> <p>Starlette: A lightweight ASGI framework designed to catch and handle incoming requests. In the context of Smyth, Starlette facilitates communication with Lambda Processes, effectively acting as a bridge that routes requests to the appropriate handlers.</p> </li> <li> <p>Lambda Process: A dedicated Python process that runs a specific Lambda Handler. The primary purpose of maintaining separate processes for each Lambda Handler is to simulate the \"warm\" state of AWS Lambda functions, allowing them to retain their state between invocations. This setup mirrors the behavior of AWS Lambda in a local development environment.</p> </li> <li> <p>Lambda Handler: The core component of your Lambda function, written as part of your project. This is the code you craft to respond to Lambda invocations, typically defined as a Python function that accepts an <code>event</code> dictionary and a <code>context</code> object. The <code>event</code> contains information about the invocation, such as the triggering event or data passed to the function, while the <code>context</code> provides runtime information about the invocation, the function, and the execution environment.</p> </li> </ul> <p>Smyth operates similarly to Serverless (offline) but is implemented in pure Python with minimal dependencies. It utilizes a Starlette endpoint to provide a catch-all route. Uvicorn, in reload mode, runs Starlette, which automatically restarts the server and refreshes all Lambda processes. At startup, the Smyth Starlette application reads a TOML configuration file, initializing a process for each defined lambda handler. These processes import the handlers and start listening on a <code>multiprocessing.Queue</code>. When a request is received, Starlette's endpoint converts it into a Lambda event and places it in the queue. The subprocess then picks it up, invokes the handler, and returns the result to the main process via the queue, which then converts it back into an HTTP response.</p> <pre><code>sequenceDiagram\n    actor User\n    participant UVIC as Uvicorn\n    participant STAR as Starlette\n    participant PROC as Lambda Process\n    participant HAND as Lambda Handler\n\n    UVIC-&gt;&gt;+STAR: Start\n    STAR-&gt;&gt;+PROC: Start\n\n    User-&gt;&gt;+UVIC: HTTP Request\n    UVIC-&gt;&gt;+STAR: ASGI Request\n\n    STAR-&gt;&gt;STAR: Lookup handlers by path\n    STAR-&gt;&gt;+PROC: Send event and context\n    alt \"Process is cold\"\n        PROC&lt;&lt;-&gt;&gt;HAND: Import handler\n    end\n    PROC-&gt;&gt;+HAND: Invoke handler\n    HAND-&gt;&gt;-PROC: Result\n    PROC-&gt;&gt;-STAR: Result\n\n    STAR-&gt;&gt;-UVIC: ASGI Response\n    UVIC-&gt;&gt;-User: HTTP Response\n\n    PROC-&gt;&gt;-STAR: Terminate\n    STAR-&gt;&gt;-UVIC: End</code></pre>"},{"location":"#others-from-mirumee","title":"Others from Mirumee","text":"<ul> <li>Lynara - Allows deploying ASGI (FastAPI, Django) applications on Lambda</li> <li>Ariadne - Schema-first, Python GraphQL server</li> <li>Ariadne Codegen - GraphQL Python code generator</li> </ul>"},{"location":"user_guide/","title":"First Steps","text":"<p>Smyth is built to have minimal or no impact on the project you are working on. That said, it comes with features that allow you to customize Smyth to the needs of your Lambda project.</p> <p>Following this guide will help you understand how to set up your development environment with Smyth.</p>"},{"location":"user_guide/#example-application","title":"Example Application","text":"<p>Throughout this guide, we will use two lambda handlers as an example application.</p> my_project/src/my_app/handlers.py<pre><code>COUNT = 0\n\ndef order_handler(event, context):\n    global COUNT\n    COUNT += 1\n    print(event, context)\n    return {\"statusCode\": 200, \"body\": f\"Orders requests: {COUNT}\"}\n\ndef product_handler(event, context):\n    global COUNT\n    COUNT += 1\n    print(event, context)\n    return {\"statusCode\": 200, \"body\": f\"Products requests: {COUNT}\"}\n</code></pre> <p>These handlers do the exact same thing, and the global <code>COUNT</code> is there to illustrate how Smyth handles state between different requests (more about that in concurrency).</p> What is the project's structure? <p>If this is in question, here is the example project's directory structure:</p> <pre><code>myproject\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 my_app\n        \u2514\u2500\u2500 handlers.py\n</code></pre>"},{"location":"user_guide/#configuration","title":"Configuration","text":"<p>Now, in our project's <code>pyproject.toml</code>, we can set up Smyth to instruct how the Lambdas will be executed. This setup reflects how your Lambdas will be deployed on AWS behind, for example, an API Gateway.</p> myproject/pyproject.toml<pre><code>[tool.smyth]\nhost = \"0.0.0.0\"  # (1)!\nport = 8080\n\n[tool.smyth.handlers.order_handler]\nhandler_path = \"my_app.handlers.order_handler\"\nurl_path = \"/orders/{path:path}\"\n\n[tool.smyth.handlers.product_handler]\nhandler_path = \"my_app.handlers.product_handler\"\nurl_path = \"/products/{path:path}\"\n</code></pre> <ol> <li>Define the host and port on which you want Uvicorn to listen.</li> </ol> <p>Under <code>tool.smyth.handlers</code>, you name and define your handlers. The only two required options are:</p> <ul> <li><code>handler_path</code> - the Python path to the Lambda handler.</li> <li><code>url_path</code> - the path with which the handler is to be reached by Starlette - uses Starlette's URL resolving.</li> </ul> <p>Custom Smyth Entrypoint</p> <p>You don't have to use the TOML config - read more about Custom Entrypoint.</p>"},{"location":"user_guide/#run-it","title":"Run It","text":"<p>At this point, you can start Smyth from your project's root directory:</p>  python -m smyth [14:12:00] INFO     [MainProcess] Uvicorn running on http://0.0.0.0:8080 (Press CTRL+C to quit)                                 config.py:523            INFO     [MainProcess] Started reloader process [22786] using StatReload                                          basereload.py:79 [14:12:00] DEBUG    [SpawnProcess-1] Using selector: KqueueSelector                                                     selector_events.py:64            INFO     [SpawnProcess-1] Started server process [22788]                                                              server.py:82            INFO     [SpawnProcess-1] Waiting for application startup.                                                                on.py:48            INFO     [SpawnProcess-1] Started process order_handler:0                                                              smyth.py:66            INFO     [SpawnProcess-1] Started process order_handler:1                                                              smyth.py:66            INFO     [SpawnProcess-1] Started process product_handler:0                                                            smyth.py:66            INFO     [SpawnProcess-1] Started process product_handler:1                                                            smyth.py:66            INFO     [SpawnProcess-1] Application startup complete.                                                                   on.py:62 <p>Visit http://localhost:8080/orders/ to get the Order Handler response.</p>"},{"location":"user_guide/all_settings/","title":"All Settings","text":"<p>Here's a list of all the settings, including those that are simpler but equally valuable, consolidated on one page:</p>"},{"location":"user_guide/all_settings/#smyth-settings","title":"Smyth Settings","text":""},{"location":"user_guide/all_settings/#socket-binding","title":"Socket Binding","text":"<p><code>host</code> - <code>str</code> (default: <code>\"0.0.0.0\"</code>) Used by Uvicorn to bind to an address.</p> <p><code>port</code> - <code>int</code> (default: <code>8080</code>) Used by Uvicorn as the bind port.</p>"},{"location":"user_guide/all_settings/#logging","title":"Logging","text":"<p><code>log_level</code> - <code>str</code> (default: <code>\"INFO\"</code>) Sets the logging level for the <code>uvicorn</code> and <code>smyth</code> logging handlers.</p>"},{"location":"user_guide/all_settings/#smyth-internals","title":"Smyth Internals","text":"<p><code>smyth_path_prefix</code> - <code>str</code> (default: <code>\"/smyth\"</code>) The path prefix used for Smyth's status endpoint. Change this if, for any reason, it collides with your path routing.</p>"},{"location":"user_guide/all_settings/#environment","title":"Environment","text":"<p><code>env</code> - <code>dict[str, str]</code> (default: <code>{}</code>) Environment variables to apply to every handler. Read more about environment variables here.</p>"},{"location":"user_guide/all_settings/#handler-settings","title":"Handler Settings","text":""},{"location":"user_guide/all_settings/#handler-path","title":"Handler Path","text":"<p><code>handler_path</code> - <code>str</code> (required) The Python path to your Lambda function.</p>"},{"location":"user_guide/all_settings/#url-path","title":"URL Path","text":"<p><code>url_path</code> - <code>str</code> (required) The Starlette routing path on which your handler will be exposed.</p>"},{"location":"user_guide/all_settings/#environment_1","title":"Environment","text":"<p><code>env</code> - <code>dict[str, str]</code> (default: <code>{}</code>) Environment variables to apply to this handler - keys defined here take precedence over the ones defined in <code>tool.smyth.env</code> and be otherwise merged. Read more about environment variables here.</p>"},{"location":"user_guide/all_settings/#customization","title":"Customization","text":"<p><code>event_data_function_path</code> - <code>str</code> (default: <code>\"smyth.event.generate_api_gw_v2_event_data\"</code>) Read more about event functions here.</p> <p><code>context_data_function_path</code> - <code>str</code> (default: <code>\"smyth.context.generate_context_data\"</code>) A function similar to the event generator, but it constructs the <code>context</code>, adding some metadata from Smyth's runtime. You can create and use your own.</p>"},{"location":"user_guide/all_settings/#behaviour","title":"Behaviour","text":"<p><code>timeout</code> - <code>float</code> (default: <code>None</code>, which means no timeout) The time in seconds after which the Lambda Handler raises a Timeout Exception, simulating Lambda's real-life timeouts.</p> <p><code>concurrency</code> - <code>int</code> (default: <code>1</code>) Read more about concurrency here.</p> <p><code>strategy_generator_path</code> - <code>str</code> (default: <code>\"smyth.runner.strategy.first_warm\"</code>) Read more about dispatch strategies here.</p>"},{"location":"user_guide/all_settings/#logging_1","title":"Logging","text":"<p><code>log_level</code> - <code>str</code> (default: <code>\"INFO\"</code>) Log level for Smyth's runner function, which is still part of Smyth but already running in the subprocess. Note that the logging of your Lambda handler code should be set separately.</p>"},{"location":"user_guide/all_settings/#pyprojecttoml-example","title":"<code>pyproject.toml</code> example","text":"pyproject.toml<pre><code>[tool.smyth]\nhost = \"0.0.0.0\"\nport = 8080\nlog_level = \"INFO\"\nsmyth_path_prefix = \"/smyth\"\n\n[tool.smyth.handlers.lambda_handler]\nhandler_path = \"myproject.app.lambda_handler\"\nurl_path = \"{path:path}\"\ntimeout = 300\nevent_data_function_path = \"smyth.event.generate_api_gw_v2_event_data\"\ncontext_data_function_path = \"smyth.context.generate_context_data\"\nlog_level = \"DEBUG\"\nconcurrency = 3\nstrategy_generator_path = \"smyth.runner.strategy.first_warm\"\n</code></pre>"},{"location":"user_guide/concurrency/","title":"Concurrency","text":"<p>Smyth can also simulate the behavior of real Lambdas in terms of multiprocessing. For instance, every Lambda invocation can be run on a different machine, not holding the state between different runtimes. To simulate this, you can set the <code>concurrency</code> setting. Don't think of it in terms of web server performance - Smyth is not meant for production to demand high performance. Instead, consider it a method to keep you in check when developing your Lambda. It serves as a reminder that not everything can be stored in globals, and that in-memory cache might not persist between runs.</p> Cold vs warm starts <p>If we take our code with one handler:</p> <pre><code>COUNT = 0\n\ndef order_handler(event, context):\n    global COUNT\n    COUNT += 1\n    print(event, context)\n    return {\"statusCode\": 200, \"body\": f\"Orders requests: {COUNT}\"}\n</code></pre> <p>Upon a cold start, the code outside of the handler function (the <code>COUNT</code> declaration in this case) will be interpreted. After that, each warm run of that Lambda will maintain the state of the <code>COUNT</code>. If the load is high enough, AWS will run more Lambdas for you, which might start from a cold state.</p> <p>To set up Smyth to run your handler in more than one subprocess, use the <code>concurrency</code> setting (by default it's <code>1</code>).</p> myproject/pyproject.toml<pre><code>[tool.smyth.handlers.order_handler]\nhandler_path = \"smyth_test_app.handlers.order_handler\"\nurl_path = \"/orders/{path:path}\"\nconcurrency = 2\n\n[tool.smyth.handlers.product_handler]\nhandler_path = \"smyth_test_app.handlers.product_handler\"\nurl_path = \"/products/{path:path}\"\nconcurrency = 2\nstrategy_function_path = \"smyth.runner.strategy.round_robin\"\n</code></pre>"},{"location":"user_guide/concurrency/#dispatch-strategy","title":"Dispatch Strategy","text":"<p>Dispatch strategy is controlled by a generator function that tells Smyth which subprocess from the pool of processes running a handler should be used. There are two built-in strategy functions:</p> <ul> <li><code>smyth.runner.strategy.first_warm</code> - (the default) tries to act like AWS, using a warmed-up Lambda (handler) if available. It only thaws a cold one if there is nothing warm or they are busy. This strategy is not ideal as it relies on the state of the process which might have changed since the generator was asked for the process, but it's good enough for a one client (you, the developer) scenario.</li> <li><code>smyth.runner.strategy.round_robin</code> - this one might keep you more in check as it picks the subprocess that was not used for the longest time, effectively using each subprocess one by one.</li> </ul> <p>You can choose the strategy function (including your own, in the same way as you would an event or context generator) with the <code>strategy_function_path</code> setting.</p>"},{"location":"user_guide/custom_entrypoint/","title":"Custom Entrypoint","text":"<p>Starting from Smyth 0.4.0, you can use it outside of the provided entrypoint (<code>python -m smyth</code>). You can build your own entrypoint for Smyth, which would not require a TOML config but instead have a Python script living in your project like any other development helper script.</p>"},{"location":"user_guide/custom_entrypoint/#example","title":"Example","text":""},{"location":"user_guide/custom_entrypoint/#project-structure","title":"Project Structure","text":"<p>Let's assume you have an <code>etc</code> directory that is not part of the final production package. Put your <code>smyth_conf.py</code> file there.</p> <pre><code>myproject\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 etc\n\u2502   \u2514\u2500\u2500 smyth_conf.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 my_app\n        \u2514\u2500\u2500 handlers.py\n</code></pre>"},{"location":"user_guide/custom_entrypoint/#your-smyth-configuration","title":"Your Smyth Configuration","text":"<p>Here's an example <code>smyth_conf.py</code> file:</p> my_project/etc/smyth_conf.py<pre><code>import uvicorn\nfrom smyth.server.app import SmythStarlette\nfrom smyth.smyth import Smyth\nfrom smyth.types import EventData, RunnerProcessProtocol, SmythHandler\nfrom starlette.requests import Request\n\n\ndef my_handler(event, context):\n    return {\"statusCode\": 200, \"body\": \"Hello, World!\"}\n\nasync def my_event_data_generator(request: Request, smyth_handler: SmythHandler, process: RunnerProcessProtocol) -&gt; EventData:\n    return {\n        \"requestContext\": {\n            \"http\": {\n                \"method\": \"GET\",\n                \"path\": \"/hello\",\n            }\n        }\n    }\n\nsmyth = Smyth()\n\nsmyth.add_handler(\n    name=\"hello\",\n    path=\"/hello\",\n    lambda_handler_path=\"smyth_run.my_handler\",\n    timeout=1,\n    concurrency=1,\n    event_data_function=my_event_data_generator,\n)\n\napp = SmythStarlette(smyth=smyth, smyth_path_prefix=\"/smyth\")\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"smyth_run:app\", host=\"0.0.0.0\", port=8080, reload=True)\n</code></pre> <p>Normally, the handler would be imported, but including the custom event generator in this file is a good use case. Use the <code>SmythStarlette</code> subclass of <code>Starlette</code> - it ensures all subprocesses are run at server start and killed on stop (using ASGI Lifetime). Create a Smyth instance and pass it to your <code>SmythStarlette</code> instance. Here, you can fine-tune logging, change Uvicorn settings, etc.</p> <p>After that, run your script:</p>  python etc/smyth_conf.py INFO:     Will watch for changes in these directories: ['/Users/pkucmus/Development/mirumee/smyth_test_app'] INFO:     Uvicorn running on http://0.0.0.0:8080 (Press CTRL+C to quit) INFO:     Started reloader process [29441] using StatReload INFO:     Started server process [29443] INFO:     Waiting for application startup. INFO:     Application startup complete."},{"location":"user_guide/environment/","title":"Environment","text":"<p>Smyth allows you to overwrite the environemnt variables that are passed to the handlers to better reflect the actual AWS Lambda environment while allowing you to change things while developing locally.</p> pyproject.toml<pre><code>[tool.smyth]\nhost = \"0.0.0.0\"\nport = 8080\n...\n\n[tool.smyth.env]\nAWS_ENDPOINT = \"http://localstack:4566\"\nAWS_LAMBDA_FUNCTION_VERSION = \"$SMYTH\"\n\n[tool.smyth.handlers.my_special_version_handler]\nhandler_path = \"mypyoject.app.my_special_version_handler\"\nurl_path = \"{path:path}\"\n...\n\n[tool.smyth.handlers.my_special_version_handler.env]\nAWS_LAMBDA_FUNCTION_VERSION = \"34\"\n</code></pre> <p>The config above allows you to set a specific env var for every defined handler and overwrite or set  specific values for individual handlers. In the example every handler would receive the  <code>AWS_ENDPOINT = \"http://localstack:4566\"</code> and <code>AWS_LAMBDA_FUNCTION_VERSION = \"$SMYTH\"</code> env vars with the exception of <code>my_special_version_handler</code> which will have a different version.</p>"},{"location":"user_guide/environment/#fake-context","title":"Fake context","text":"<p>The <code>smyth.runner.fake_context.FakeLambdaContext</code> class used by Smyth will also consume of of the environment variables.</p>"},{"location":"user_guide/environment/#default-variables","title":"Default variables","text":"<p>In the table bellow you will find which keys are set by Smyth when a handler is being invoked.  Smyth will look for the key in the following order:</p> <ol> <li>the handler configuration <code>env</code> key</li> <li>the smyth global configuration <code>env</code> key</li> <li><code>os.environ</code></li> <li>when none of the above contain the key the default value is assigned</li> </ol> Key Default Value <code>\"_HANDLER\"</code> <code>self.lambda_handler_path</code> <code>\"AWS_ACCESS_KEY_ID\"</code> <code>\"000000000000\"</code> <code>\"AWS_SECRET_ACCESS_KEY\"</code> <code>\"test\"</code> <code>\"AWS_SESSION_TOKEN\"</code> <code>\"test\"</code> <code>\"AWS_DEFAULT_REGION\"</code> <code>\"eu-central-1\"</code> <code>\"AWS_REGION\"</code> <code>\"eu-central-1\"</code> <code>\"AWS_EXECUTION_ENV\"</code> <code>\"AWS_Lambda_python{sys.version_info.major}.{sys.version_info.minor}\"</code> <code>\"AWS_LAMBDA_FUNCTION_MEMORY_SIZE\"</code> <code>\"128\"</code> <code>\"AWS_LAMBDA_FUNCTION_NAME\"</code> <code>self.name</code> <code>\"AWS_LAMBDA_FUNCTION_VERSION\"</code> <code>\"$LATEST\"</code> <code>\"AWS_LAMBDA_INITIALIZATION_TYPE\"</code> <code>\"on-demand\"</code> <code>\"AWS_LAMBDA_LOG_GROUP_NAME\"</code> <code>\"/aws/lambda/{self.name}\"</code> <code>\"AWS_LAMBDA_LOG_STREAM_NAME\"</code> <code>\"{strftime('%Y/%m/%d')}/[$LATEST]smyth_aws_lambda_log_stream_name\"</code> <code>\"AWS_LAMBDA_RUNTIME_API\"</code> <code>\"127.0.0.1:9001\"</code> <code>\"AWS_XRAY_CONTEXT_MISSING\"</code> <code>\"LOG_ERROR\"</code> <code>\"AWS_XRAY_DAEMON_ADDRESS\"</code> <code>\"127.0.0.1:2000\"</code>"},{"location":"user_guide/event_functions/","title":"Event Generators","text":"<p>An event generator is a simple coroutine used by Smyth to transform a Starlette <code>Request</code> instance into an <code>event</code> dictionary that is eventually used when invoking the Lambda handler.</p> <p>Smyth comes with two built-in event generators: <code>smyth.event.generate_api_gw_v2_event_data</code> (used by default) and <code>smyth.event.generate_lambda_invocation_event_data</code>, which is used in the invocation endpoint.</p> <p>The first one builds a minimal API Gateway Proxy V2 event to simulate a Lambda being triggered by one. The other deserializes the request body (assumes it's proper JSON) and returns just that.</p>"},{"location":"user_guide/event_functions/#custom-event-generators","title":"Custom Event Generators","text":""},{"location":"user_guide/event_functions/#example-generator","title":"Example Generator","text":"<p>If you need to work with events not covered by Smyth, you can create and provide your own. Assuming a simplified API Gateway V1 event, you can create a generator like this:</p> my_project/src/smyth_utils/event.py<pre><code>from smyth.types import EventData, RunnerProcessProtocol, SmythHandler\n\n\nasync def generate_api_gw_v1_event_data(request: Request, smyth_handler: SmythHandler, process: RunnerProcessProtocol) -&gt; EventData:\n    source_ip = None\n    if request.client:\n        source_ip = request.client.host\n\n    return {\n        \"resource\": request.url.path,\n        \"path\": request.url.path,\n        \"httpMethod\": request.method,\n        \"headers\": dict(request.headers),\n        \"queryStringParameters\": dict(request.query_params),\n        \"pathParameters\": {},  # You may need to populate this based on your routing\n        \"stageVariables\": None,\n        \"requestContext\": {\n            \"resourceId\": \"offlineContext_resourceId\",\n            \"resourcePath\": request.url.path,\n            \"httpMethod\": request.method,\n            \"extendedRequestId\": \"offlineContext_extendedRequestId\",\n            \"requestTime\": \"21/Nov/2020:20:13:27 +0000\",\n            \"path\": request.url.path,\n            \"accountId\": \"offlineContext_accountId\",\n            \"protocol\": request.url.scheme,\n            \"stage\": \"dev\",\n            \"domainPrefix\": \"offlineContext_domainPrefix\",\n            \"requestTimeEpoch\": int(request.timestamp().timestamp() * 1000),\n            \"requestId\": \"offlineContext_requestId\",\n            \"identity\": {\n                ...\n            },\n            \"domainName\": \"offlineContext_domainName\",\n            \"apiId\": \"offlineContext_apiId\"\n        },\n        \"body\": (await request.body()).decode(\"utf-8\"),\n        \"isBase64Encoded\": False\n    }\n</code></pre> <p>This is example code; a proper API Gateway V1 generator might need to be different.</p>"},{"location":"user_guide/event_functions/#configuration","title":"Configuration","text":"myproject/pyproject.toml<pre><code>[tool.smyth]\nhost = \"0.0.0.0\"\nport = 8080\n\n[tool.smyth.handlers.order_handler]\nhandler_path = \"my_app.handlers.order_handler\"\nurl_path = \"/orders/{path:path}\"\nevent_data_function_path = \"smyth_utils.event.generate_api_gw_v1_event_data\"\n\n[tool.smyth.handlers.product_handler]\nhandler_path = \"my_app.handlers.product_handler\"\nurl_path = \"/products/{path:path}\"\n</code></pre> <p>Note that <code>smyth_utils</code> needs to be in your Python path.</p> <p>From this point on, the <code>order_handler</code> will receive a different <code>event</code> than the <code>product_handler</code>.</p>"},{"location":"user_guide/event_functions/#limited-built-in-generators","title":"Limited Built-in Generators","text":"<p>We provided a limited number of generators because there are many possibilities for event simulation. Simulating DynamoDB streams or SQS events locally might be appealing, but we were unsure how these would be used in real-life scenarios. We'd love to hear from the community about this - please don't hesitate to report  GitHub issues with proposals on what event generators we should include in Smyth.</p>"},{"location":"user_guide/invoke/","title":"Lambda Invoke","text":"<p>An important aspect when working with Lambdas is the ability to invoke one like a remote function. The Boto3 <code>Lambda.Client.invoke</code> function is one way to run your Lambda code. Smyth recognizes the need to simulate that as well.</p>"},{"location":"user_guide/invoke/#example","title":"Example","text":"my_project/src/my_app/handlers.py<pre><code>import boto3\n\nlambda_client = boto3.client(\n    \"lambda\", \n    endpoint_url=\"http://localhost:8080\"  # (1)!\n)  \n\ndef order_handler(event, context):\n    lambda_client.invoke(\n        FunctionName=\"email_handler\",  # (3)!\n        InvocationType=\"Event\",  # or RequestResponse\n        Payload=b'{\"to\": \"hello@mirumee.com\", \"subject\": \"Order made\"}',\n    )\n    return {\"statusCode\": 200, \"body\": f\"Orders requests: {COUNT}\"}\n\ndef email_handler(event, context):\n    print(event)  # (2)!\n    return {\"statusCode\": 200, \"body\": f\"Products requests: {COUNT}\"}\n</code></pre> <ol> <li>Set the endpoint URL to your Smyth host and port.</li> <li>The payload being sent to the handler: <code>{\"to\": \"hello@mirumee.com\", \"subject\": \"Order made\"}</code>.</li> <li>Corresponds to the TOML config <code>[tool.smyth.handlers.email_handler]</code>.</li> </ol>"},{"location":"user_guide/invoke/#how-it-works","title":"How It Works","text":"<p>No matter what <code>url_path</code> your handler is registered under in your config, every handler is also available via Smyth's <code>\"/2015-03-31/functions/{function:str}/invocations\"</code> URL. The difference from the <code>url_path</code> invocation is that when using the \"direct invocation,\" the event generator is hardcoded to the <code>smyth.event.generate_lambda_invocation_event_data</code> function.</p> <p>In the example above, the config might look like this:</p> myproject/pyproject.toml<pre><code>[tool.smyth]\nhost = \"0.0.0.0\"\nport = 8080\n\n[tool.smyth.handlers.order_handler]\nhandler_path = \"my_app.handlers.order_handler\"\nurl_path = \"/orders/{path:path}\"\n\n[tool.smyth.handlers.email_handler]\nhandler_path = \"my_app.handlers.email_handler\"\nurl_path = \"/emails/{path:path}\"\n</code></pre> <p>Line 9, which names the handler, is the important one here. Line 11 is required, but you don't have to use the HTTP request method to reach that handler.</p>"},{"location":"user_guide/non_http/","title":"Non-HTTP Invocation","text":"<p>You don't need Uvicorn and Starlette to use Smyth. Testing your Lambdas that handle events such as SQS, DynamoDB, etc., is also possible with Smyth. You can achieve this by creating an entrypoint script similar to the one in Custom Entrypoint.</p>"},{"location":"user_guide/non_http/#example","title":"Example","text":"<p>In your <code>etc</code> directory, create a <code>smyth_run.py</code> file.</p> Skip to the full file? my_project/etc/smyth_run.py<pre><code>import asyncio\n\nfrom smyth.runner.strategy import round_robin\nfrom smyth.smyth import Smyth\n\ndef my_handler(event, context):\n    print(event[\"Records\"][0][\"body\"], context.smyth[\"process\"][\"name\"])\n\nEVENT_DATA = {\n    \"Records\": [\n        {\n            \"messageId\": \"19dd0b57-b21e-4ac1-bd88-01bbb068cb78\",\n            \"receiptHandle\": \"MessageReceiptHandle\",\n            \"body\": \"Hello from SQS!\",\n            \"attributes\": {\n                \"ApproximateReceiveCount\": \"1\",\n                \"SentTimestamp\": \"1523232000000\",\n                \"SenderId\": \"123456789012\",\n                \"ApproximateFirstReceiveTimestamp\": \"1523232000001\",\n            },\n            \"messageAttributes\": {},\n            \"md5OfBody\": \"7b270e59b47ff90a553787216d55d91d\",\n            \"eventSource\": \"aws:sqs\",\n            \"eventSourceARN\": \"arn:aws:sqs:us-east-1:123456789012:MyQueue\",\n            \"awsRegion\": \"us-east-1\",\n        }\n    ]\n}\n\nsmyth = Smyth()\n\nsmyth.add_handler(\n    name=\"hello\",\n    path=\"/hello\",\n    lambda_handler_path=\"smyth_run.my_handler\",\n    timeout=60,\n    concurrency=10,\n    strategy_generator=round_robin,\n)\n\nasync def main():\n    handler = smyth.get_handler_for_name(\"hello\")\n    await asyncio.gather(\n        *[\n            smyth.invoke(\n                handler=handler,\n                event_data=EVENT_DATA,\n            )\n            for _ in range(20)\n        ],\n        return_exceptions=True,\n    )\n\nif __name__ == \"__main__\":\n    with smyth:\n        asyncio.run(main())\n</code></pre>"},{"location":"user_guide/non_http/#import-and-declare-the-basics","title":"Import and Declare the Basics","text":"<p>Import <code>asyncio</code>, <code>smyth</code>, and your Lambda handler function.</p> my_project/etc/smyth_run.py<pre><code>import asyncio\n\nfrom smyth.runner.strategy import round_robin\nfrom smyth.smyth import Smyth\n\ndef my_handler(event, context):\n    print(event[\"Records\"][0][\"body\"], context.smyth[\"process\"][\"name\"])\n</code></pre>"},{"location":"user_guide/non_http/#create-the-event-data","title":"Create the Event Data","text":"<p>This example comes from <code>sam local generate-event sqs receive-message</code>. Yours might be more complex.</p> my_project/etc/smyth_run.py<pre><code>EVENT_DATA = {\n    \"Records\": [\n        {\n            \"messageId\": \"19dd0b57-b21e-4ac1-bd88-01bbb068cb78\",\n            \"receiptHandle\": \"MessageReceiptHandle\",\n            \"body\": \"Hello from SQS!\",\n            \"attributes\": {\n                \"ApproximateReceiveCount\": \"1\",\n                \"SentTimestamp\": \"1523232000000\",\n                \"SenderId\": \"123456789012\",\n                \"ApproximateFirstReceiveTimestamp\": \"1523232000001\",\n            },\n            \"messageAttributes\": {},\n            \"md5OfBody\": \"7b270e59b47ff90a553787216d55d91d\",\n            \"eventSource\": \"aws:sqs\",\n            \"eventSourceARN\": \"arn:aws:sqs:us-east-1:123456789012:MyQueue\",\n            \"awsRegion\": \"us-east-1\",\n        }\n    ]\n}\n</code></pre>"},{"location":"user_guide/non_http/#instantiate-smyth-and-add-handlers","title":"Instantiate Smyth and Add Handlers","text":"<p>Initialize Smyth and add your handlers.</p> my_project/etc/smyth_run.py<pre><code>smyth = Smyth()\n\nsmyth.add_handler(\n    name=\"hello\",\n    path=\"/hello\",\n    lambda_handler_path=\"smyth_run.my_handler\",\n    timeout=60,\n    concurrency=10,\n    strategy_generator=round_robin,\n)\n</code></pre>"},{"location":"user_guide/non_http/#prepare-the-main-function","title":"Prepare the Main Function","text":"<p>This part depends on what you want to achieve. Here we are trying to simulate a bunch of SQS messages quickly triggering a handler.</p> my_project/etc/smyth_run.py<pre><code>async def main():\n    handler = smyth.get_handler_for_name(\"hello\")\n    await asyncio.gather(\n        *[\n            smyth.invoke(\n                handler=handler,\n                event_data=EVENT_DATA,\n            )\n            for _ in range(20)\n        ],\n        return_exceptions=True,\n    )\n\nif __name__ == \"__main__\":\n    with smyth:\n        asyncio.run(main())\n</code></pre>"},{"location":"user_guide/non_http/#run-it","title":"Run It","text":"python etc/smyth_run.py Hello from SQS! hello:8 Hello from SQS! hello:4 Hello from SQS! hello:5 Hello from SQS! hello:3 Hello from SQS! hello:1 Hello from SQS! hello:2 Hello from SQS! hello:6 Hello from SQS! hello:4 Hello from SQS! hello:3 Hello from SQS! hello:1 Hello from SQS! hello:0 Hello from SQS! hello:5 Hello from SQS! hello:8 Hello from SQS! hello:2 Hello from SQS! hello:0 Hello from SQS! hello:6 Hello from SQS! hello:9 Hello from SQS! hello:9 Hello from SQS! hello:7 Hello from SQS! hello:7"}]}